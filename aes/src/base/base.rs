use super::super::tables::{RCON, ROUND_KEYS_128, SBOX_ENCRYPT};

#[derive(Debug, Copy, Clone)]
pub struct Word {
    data: [u8; 4],
}

impl Word {
    fn new(data: [u8; 4]) -> Self {
        Self { data }
    }

    fn rotate(&mut self) {
        self.data.rotate_left(1);
    }

    fn substitute(&mut self, sbox: &[u8; 256]) {
        for byte in &mut self.data {
            *byte = sbox[*byte as usize];
        }
    }

    fn xor(&mut self, other: &Word) {
        for i in 0..4 {
            self.data[i] ^= other.data[i];
        }
    }

    fn xor_rcon(&mut self, rcon: [u8; 4]) {
        for i in 0..4 {
            self.data[i] ^= rcon[i];
        }
    }
}

struct KeySchedule {
    schedule: [[Word; 4]; 11],
    rcon: [[u8; 4]; 10],
    sbox: [u8; 256],
}

impl KeySchedule {
    pub fn new(key: &[u8; 16], rcon: [[u8; 4]; 10], sbox: [u8; 256]) -> Self {
        let mut schedule = [[Word::new([0u8; 4]); 4]; 11];

        for (i, chunk) in key.chunks(4).enumerate() {
            schedule[0][i] = Word::new(chunk.try_into().unwrap());
        }

        Self {
            schedule,
            rcon,
            sbox,
        }
    }

    fn get_word(&self, round: usize, pos: usize) -> Word {
        Word::new(self.schedule[round][pos].data)
    }

    fn core_transform(&self, mut word: Word, round: usize) -> Word {
        word.rotate();
        word.substitute(&self.sbox);
        word.xor_rcon(self.rcon[round]);

        word
    }

    fn expand(&mut self) {
        for round in 0..10 {
            let mut transformation = self.get_word(round, 3);
            transformation = self.core_transform(transformation, round);
            transformation.xor(&self.get_word(round, 0));

            self.schedule[round + 1][0] = transformation;

            for pos in 1..4 {
                let mut next_word = self.get_word(round + 1, pos - 1);
                next_word.xor(&self.get_word(round, pos));
                self.schedule[round + 1][pos] = next_word;
            }
        }
    }

    fn into_expanded_key(self) -> [u8; 176] {
        unsafe { std::mem::transmute(self.schedule) }
    }
}

#[derive(Debug, Clone, Copy)]
pub struct Aes128 {
    pub key: [u8; 16],
    pub key_expansion: [u8; 176],
    pub rounds: usize,
}

impl Aes128 {
    pub fn new(key: [u8; 16]) -> Self {
        let mut aes = Aes128 {
            key,
            key_expansion: [0u8; 176],
            rounds: ROUND_KEYS_128,
        };

        aes.expand_key();
        aes
    }

    // key schedule generation
    fn expand_key(&mut self) {
        let mut schedule = KeySchedule::new(&self.key, RCON, SBOX_ENCRYPT);
        schedule.expand();

        self.key_expansion = schedule.into_expanded_key();
    }

    pub fn get_round_key(&self, round: usize) -> [u8; 16] {
        let offset = round * 16;

        self.key_expansion[offset..offset + 16].try_into().unwrap()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const KEY: [u8; 16] = [
        0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f,
        0x3c,
    ];

    #[test]
    fn get_round_key_test() {
        // 47j to skip past this const
        const ROUND_KEYS_EXPECTED: [[u8; 16]; 11] = [
            [
                0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x9, 0xcf,
                0x4f, 0x3c,
            ],
            [
                0xa0, 0xfa, 0xfe, 0x17, 0x88, 0x54, 0x2c, 0xb1, 0x23, 0xa3, 0x39, 0x39, 0x2a, 0x6c,
                0x76, 0x5,
            ],
            [
                0xf2, 0xc2, 0x95, 0xf2, 0x7a, 0x96, 0xb9, 0x43, 0x59, 0x35, 0x80, 0x7a, 0x73, 0x59,
                0xf6, 0x7f,
            ],
            [
                0x3d, 0x80, 0x47, 0x7d, 0x47, 0x16, 0xfe, 0x3e, 0x1e, 0x23, 0x7e, 0x44, 0x6d, 0x7a,
                0x88, 0x3b,
            ],
            [
                0xef, 0x44, 0xa5, 0x41, 0xa8, 0x52, 0x5b, 0x7f, 0xb6, 0x71, 0x25, 0x3b, 0xdb, 0xb,
                0xad, 0x0,
            ],
            [
                0xd4, 0xd1, 0xc6, 0xf8, 0x7c, 0x83, 0x9d, 0x87, 0xca, 0xf2, 0xb8, 0xbc, 0x11, 0xf9,
                0x15, 0xbc,
            ],
            [
                0x6d, 0x88, 0xa3, 0x7a, 0x11, 0xb, 0x3e, 0xfd, 0xdb, 0xf9, 0x86, 0x41, 0xca, 0x0,
                0x93, 0xfd,
            ],
            [
                0x4e, 0x54, 0xf7, 0xe, 0x5f, 0x5f, 0xc9, 0xf3, 0x84, 0xa6, 0x4f, 0xb2, 0x4e, 0xa6,
                0xdc, 0x4f,
            ],
            [
                0xea, 0xd2, 0x73, 0x21, 0xb5, 0x8d, 0xba, 0xd2, 0x31, 0x2b, 0xf5, 0x60, 0x7f, 0x8d,
                0x29, 0x2f,
            ],
            [
                0xac, 0x77, 0x66, 0xf3, 0x19, 0xfa, 0xdc, 0x21, 0x28, 0xd1, 0x29, 0x41, 0x57, 0x5c,
                0x0, 0x6e,
            ],
            [
                0xd0, 0x14, 0xf9, 0xa8, 0xc9, 0xee, 0x25, 0x89, 0xe1, 0x3f, 0xc, 0xc8, 0xb6, 0x63,
                0xc, 0xa6,
            ],
        ];

        let schedule = Aes128::new(KEY);
        for round in 0..11 {
            let round_key_expected = ROUND_KEYS_EXPECTED[round];
            assert_eq!(schedule.get_round_key(round), round_key_expected);
        }
    }

    #[test]
    fn key_schedule_test() {
        let schedule = Aes128::new(KEY);
        let expects = [
            0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf,
            0x4f, 0x3c, 0xa0, 0xfa, 0xfe, 0x17, 0x88, 0x54, 0x2c, 0xb1, 0x23, 0xa3, 0x39, 0x39,
            0x2a, 0x6c, 0x76, 0x05, 0xf2, 0xc2, 0x95, 0xf2, 0x7a, 0x96, 0xb9, 0x43, 0x59, 0x35,
            0x80, 0x7a, 0x73, 0x59, 0xf6, 0x7f, 0x3d, 0x80, 0x47, 0x7d, 0x47, 0x16, 0xfe, 0x3e,
            0x1e, 0x23, 0x7e, 0x44, 0x6d, 0x7a, 0x88, 0x3b, 0xef, 0x44, 0xa5, 0x41, 0xa8, 0x52,
            0x5b, 0x7f, 0xb6, 0x71, 0x25, 0x3b, 0xdb, 0x0b, 0xad, 0x00, 0xd4, 0xd1, 0xc6, 0xf8,
            0x7c, 0x83, 0x9d, 0x87, 0xca, 0xf2, 0xb8, 0xbc, 0x11, 0xf9, 0x15, 0xbc, 0x6d, 0x88,
            0xa3, 0x7a, 0x11, 0x0b, 0x3e, 0xfd, 0xdb, 0xf9, 0x86, 0x41, 0xca, 0x00, 0x93, 0xfd,
            0x4e, 0x54, 0xf7, 0x0e, 0x5f, 0x5f, 0xc9, 0xf3, 0x84, 0xa6, 0x4f, 0xb2, 0x4e, 0xa6,
            0xdc, 0x4f, 0xea, 0xd2, 0x73, 0x21, 0xb5, 0x8d, 0xba, 0xd2, 0x31, 0x2b, 0xf5, 0x60,
            0x7f, 0x8d, 0x29, 0x2f, 0xac, 0x77, 0x66, 0xf3, 0x19, 0xfa, 0xdc, 0x21, 0x28, 0xd1,
            0x29, 0x41, 0x57, 0x5c, 0x00, 0x6e, 0xd0, 0x14, 0xf9, 0xa8, 0xc9, 0xee, 0x25, 0x89,
            0xe1, 0x3f, 0x0c, 0xc8, 0xb6, 0x63, 0x0c, 0xa6,
        ];

        assert_eq!(schedule.key_expansion, expects);
    }
}
